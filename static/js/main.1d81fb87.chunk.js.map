{"version":3,"sources":["Types.ts","components/PlayerName/PlayerName.tsx","rules/GeneralRules.ts","rules/PawnRules.ts","rules/KnightRules.ts","rules/BishopRules.ts","rules/RookRules.ts","rules/QueenRules.ts","rules/KingRules.ts","models/Board.ts","models/Piece.ts","models/Position.ts","components/Tile/Tile.tsx","Constants.ts","components/Chessboard/Chessboard.tsx","components/Arbiter/Arbiter.tsx","App.tsx","index.tsx"],"names":["PieceType","TeamType","PlayerName","_ref","whoseTurn","lostTeams","React","createElement","Fragment","className","RED","includes","filter","x","join","BLUE","YELLOW","GREEN","tileIsOccupied","position","boardState","find","p","samePosition","tileIsOccupiedByOpponent","team","tileIsEmptyOrOccupiedByOpponent","getPossiblePawnMoves","pawn","possibleMoves","specialRow","pawnDirection","normalMove","Position","specialMove","upperLeftAttack","upperRightAttack","y","push","getPossibleKnightMoves","knight","i","j","verticalMove","horizontalMove","getPossibleBishopMoves","bishop","destination","getPossibleRookMoves","rook","getPossibleQueenMoves","queen","getPossibleKingMoves","king","getCastlingMoves","hasMoved","rooks","isRook","_rook$possibleMoves","direction","adjacentPosition","clone","some","m","concerningTiles","enemyPieces","valid","enemy","move","t","Board","constructor","pieces","totalTurns","currentTeam","arguments","length","undefined","loseOrder","this","gameOver","getNextTeam","teams","indexOf","calculateAllMoves","piece","getValidMoves","isKing","checkCurrentTeamMoves","lostTeam","simulatedBoard","samePiecePosition","clonedKing","_piece$possibleMoves","_piece$possibleMoves2","isPawn","isChecked","type","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","playMove","playedPiece","destinationPiece","newKingXPosition","map","newKingYPosition","reduce","results","Piece","image","basePath","window","location","hostname","otherPiece","otherPosition","_this$possibleMoves","Tile","num_i","num_j","highlight","teamLost","check","Boolean","style","backgroundImage","VERTICAL_AXIS","HORIZONTAL_AXIS","GRID_SIZE","initialBoard","Chessboard","activePiece","setActivePiece","useState","grabPosition","setGrabPosition","isClicked","setIsClicked","chessboardRef","useRef","board","currentPiece","key","onMouseMove","e","chessboard","current","leftX","offsetLeft","midleftX","clientWidth","topY","offsetTop","midtopY","clientHeight","rightX","midrightX","bottomY","midbottomY","clientX","clientY","left","top","movePiece","onMouseDown","element","target","classList","contains","grabX","Math","floor","grabY","abs","ceil","zIndex","document","body","userSelect","grabPiece","onClick","clickPiece","onMouseUp","removeProperty","dropPiece","id","ref","Arbiter","setBoard","promotionPawn","setPromotionPawn","modalRef","checkmateModalRef","promotePawn","pieceType","_modalRef$current2","previousBoard","clonedBoard","add","promotionTeamType","teamNames","[object Object]","teamWon","leaderboard","slice","reverse","lbPieces","pieceNames","Q","R","N","P","src","alt","_checkmateModalRef$cu2","_playedPiece$possible","_modalRef$current","_checkmateModalRef$cu","remove","previousPromotionPawn","clonedPlayedPiece","App","ReactDOM","createRoot","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.1d81fb87.chunk.js","sourcesContent":["// PieceType enum\nexport enum PieceType {\n  PAWN = 'P',\n  BISHOP = 'B',\n  KNIGHT = 'N',\n  ROOK = 'R',\n  QUEEN = 'Q',\n  KING = 'K',\n}\n\n// TeamType enum\nexport enum TeamType {\n  RED = 'r',\n  BLUE = 'b',\n  YELLOW = 'y',\n  GREEN = 'g',\n}\n","import { TeamType } from '../../Types'\nimport './PlayerName.css'\nimport React from 'react'\ninterface Props {\n  whoseTurn: TeamType\n  lostTeams: TeamType[]\n}\n// Color names for the different players\nexport default function PlayerName({ whoseTurn, lostTeams }: Props) {\n  return (\n    <>\n      <div\n        className={[\n          'playerName',\n          'team-red',\n          whoseTurn === TeamType.RED && 'player-active',\n          lostTeams.includes(TeamType.RED) && 'player-lost',\n        ]\n          .filter((x) => x)\n          .join(' ')}\n      >\n        Player RED\n      </div>\n      <div\n        className={[\n          'playerName',\n          'team-blue',\n          whoseTurn === TeamType.BLUE && 'player-active',\n          lostTeams.includes(TeamType.BLUE) && 'player-lost',\n        ]\n          .filter((x) => x)\n          .join(' ')}\n      >\n        Player BLUE\n      </div>\n      <div\n        className={[\n          'playerName',\n          'team-yellow',\n          whoseTurn === TeamType.YELLOW && 'player-active',\n          lostTeams.includes(TeamType.YELLOW) && 'player-lost',\n        ]\n          .filter((x) => x)\n          .join(' ')}\n      >\n        Player YELLOW\n      </div>\n      <div\n        className={[\n          'playerName',\n          'team-green',\n          whoseTurn === TeamType.GREEN && 'player-active',\n          lostTeams.includes(TeamType.GREEN) && 'player-lost',\n        ]\n          .filter((x) => x)\n          .join(' ')}\n      >\n        Player GREEN\n      </div>\n    </>\n  )\n}\n","import { Piece, Position } from '../models'\nimport { TeamType } from '../Types'\n\n// Checking if the tile is occupied or not\nexport const tileIsOccupied = (\n  position: Position,\n  boardState: Piece[]\n): boolean => {\n  const piece = boardState.find((p) => p.samePosition(position))\n\n  if (piece) {\n    return true\n  } else {\n    return false\n  }\n}\n\n// Checking if the tile is occupied by opponent or not\nexport const tileIsOccupiedByOpponent = (\n  position: Position,\n  boardState: Piece[],\n  team: TeamType\n): boolean => {\n  const piece = boardState.find(\n    (p) => p.samePosition(position) && p.team !== team\n  )\n\n  if (piece) {\n    return true\n  } else {\n    return false\n  }\n}\n\n// Checking if the tile is empty or occupied by an opponent\nexport const tileIsEmptyOrOccupiedByOpponent = (\n  position: Position,\n  boardState: Piece[],\n  team: TeamType\n) => {\n  return (\n    !tileIsOccupied(position, boardState) ||\n    tileIsOccupiedByOpponent(position, boardState, team)\n  )\n}\n","import { Piece, Position } from '../models'\nimport { TeamType } from '../Types'\nimport { tileIsOccupied, tileIsOccupiedByOpponent } from './GeneralRules'\n\n// Rules to move the Pawns\nexport const pawnMove = (\n  initialPosition: Position,\n  desiredPosition: Position,\n  team: TeamType,\n  boardState: Piece[]\n): boolean => {\n  const specialRow = team === TeamType.RED || team === TeamType.BLUE ? 1 : 12\n  const pawnDirection = team === TeamType.RED || team === TeamType.BLUE ? 1 : -1\n\n  // Red and Yellow Pawn\n  if (team === TeamType.RED || team === TeamType.YELLOW) {\n    // Movement Logic\n    if (\n      initialPosition.x === desiredPosition.x &&\n      initialPosition.y === specialRow &&\n      desiredPosition.y - initialPosition.y === 2 * pawnDirection\n    ) {\n      if (\n        !tileIsOccupied(desiredPosition, boardState) &&\n        !tileIsOccupied(\n          new Position(desiredPosition.x, desiredPosition.y - pawnDirection),\n          boardState\n        )\n      ) {\n        return true\n      }\n    } else if (\n      initialPosition.x === desiredPosition.x &&\n      desiredPosition.y - initialPosition.y === pawnDirection\n    ) {\n      if (!tileIsOccupied(desiredPosition, boardState)) {\n        return true\n      }\n    }\n    // Attack Logic\n    else if (\n      desiredPosition.x - initialPosition.x === -1 &&\n      desiredPosition.y - initialPosition.y === pawnDirection\n    ) {\n      // Attack in Upper or Bottom Left Corner\n      if (tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {\n        return true\n      }\n    } else if (\n      desiredPosition.x - initialPosition.x === 1 &&\n      desiredPosition.y - initialPosition.y === pawnDirection\n    ) {\n      // Attack in Upper or Bottom Right Corner\n      if (tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {\n        return true\n      }\n    }\n  }\n\n  // Green and Blue Pawn\n  else {\n    // Movement Logic\n    if (\n      initialPosition.y === desiredPosition.y &&\n      initialPosition.x === specialRow &&\n      desiredPosition.x - initialPosition.x === 2 * pawnDirection\n    ) {\n      if (\n        !tileIsOccupied(desiredPosition, boardState) &&\n        !tileIsOccupied(\n          new Position(desiredPosition.x - pawnDirection, desiredPosition.y),\n          boardState\n        )\n      ) {\n        return true\n      }\n    } else if (\n      initialPosition.y === desiredPosition.y &&\n      desiredPosition.x - initialPosition.x === pawnDirection\n    ) {\n      if (!tileIsOccupied(desiredPosition, boardState)) {\n        return true\n      }\n    }\n    // Attack Logic\n    else if (\n      desiredPosition.y - initialPosition.y === -1 &&\n      desiredPosition.x - initialPosition.x === pawnDirection\n    ) {\n      // Attack in Right or Left Bottom Corner\n      if (tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {\n        return true\n      }\n    } else if (\n      desiredPosition.y - initialPosition.y === 1 &&\n      desiredPosition.x - initialPosition.x === pawnDirection\n    ) {\n      // Attack in Right or Left Upper Corner\n      if (tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\n// Checking possible moves for the Pawns to highlight the grids\nexport const getPossiblePawnMoves = (\n  pawn: Piece,\n  boardState: Piece[]\n): Position[] => {\n  const possibleMoves: Position[] = []\n\n  const specialRow =\n    pawn.team === TeamType.RED || pawn.team === TeamType.BLUE ? 1 : 12\n  const pawnDirection =\n    pawn.team === TeamType.RED || pawn.team === TeamType.BLUE ? 1 : -1\n\n  let normalMove = new Position(-1, -1)\n  let specialMove = new Position(-1, -1)\n  let upperLeftAttack = new Position(-1, -1)\n  let upperRightAttack = new Position(-1, -1)\n\n  // For red and yellow pawns\n  if (pawn.team === TeamType.RED || pawn.team === TeamType.YELLOW) {\n    normalMove = new Position(pawn.position.x, pawn.position.y + pawnDirection)\n    specialMove = new Position(normalMove.x, normalMove.y + pawnDirection)\n    upperLeftAttack = new Position(\n      pawn.position.x - 1,\n      pawn.position.y + pawnDirection\n    )\n    upperRightAttack = new Position(\n      pawn.position.x + 1,\n      pawn.position.y + pawnDirection\n    )\n  }\n\n  // For green and blue pawns\n  else {\n    normalMove = new Position(pawn.position.x + pawnDirection, pawn.position.y)\n    specialMove = new Position(normalMove.x + pawnDirection, normalMove.y)\n    upperLeftAttack = new Position(\n      pawn.position.x + pawnDirection,\n      pawn.position.y - 1\n    )\n    upperRightAttack = new Position(\n      pawn.position.x + pawnDirection,\n      pawn.position.y + 1\n    )\n  }\n\n  // Checking for possible moves\n  if (!tileIsOccupied(normalMove, boardState)) {\n    possibleMoves.push(normalMove)\n\n    if (\n      (pawn.position.y === specialRow || pawn.position.x === specialRow) &&\n      !tileIsOccupied(specialMove, boardState)\n    ) {\n      possibleMoves.push(specialMove)\n    }\n  }\n\n  if (tileIsOccupiedByOpponent(upperLeftAttack, boardState, pawn.team)) {\n    possibleMoves.push(upperLeftAttack)\n  }\n\n  if (tileIsOccupiedByOpponent(upperRightAttack, boardState, pawn.team)) {\n    possibleMoves.push(upperRightAttack)\n  }\n\n  return possibleMoves\n}\n","import { Piece, Position } from '../models'\nimport { TeamType } from '../Types'\nimport { tileIsEmptyOrOccupiedByOpponent } from './GeneralRules'\n\n// Rules to move the Knights\nexport const knightMove = (\n  initialPosition: Position,\n  desiredPosition: Position,\n  team: TeamType,\n  boardState: Piece[]\n): boolean => {\n  // Movement and Attack Logic for Knight\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      // Top and Bottom Side Movement\n      if (desiredPosition.y - initialPosition.y === 2 * i) {\n        if (desiredPosition.x - initialPosition.x === j) {\n          if (\n            tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team)\n          ) {\n            return true\n          }\n        }\n      }\n\n      // Right and Left Side Movement\n      if (desiredPosition.x - initialPosition.x === 2 * i) {\n        if (desiredPosition.y - initialPosition.y === j) {\n          if (\n            tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team)\n          ) {\n            return true\n          }\n        }\n      }\n    }\n  }\n\n  return false\n}\n\n// Checking possible moves for the Knights to highlight the grids\nexport const getPossibleKnightMoves = (\n  knight: Piece,\n  boardState: Piece[]\n): Position[] => {\n  const possibleMoves: Position[] = []\n\n  // Movement and Attack Logic for Knight\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      const verticalMove = new Position(\n        knight.position.x + j,\n        knight.position.y + i * 2\n      )\n      const horizontalMove = new Position(\n        knight.position.x + i * 2,\n        knight.position.y + j\n      )\n\n      if (\n        tileIsEmptyOrOccupiedByOpponent(verticalMove, boardState, knight.team)\n      ) {\n        possibleMoves.push(verticalMove)\n      }\n\n      if (\n        tileIsEmptyOrOccupiedByOpponent(horizontalMove, boardState, knight.team)\n      ) {\n        possibleMoves.push(horizontalMove)\n      }\n    }\n  }\n\n  return possibleMoves\n}\n","import { Piece, Position } from '../models'\nimport { TeamType } from '../Types'\nimport {\n  tileIsOccupied,\n  tileIsOccupiedByOpponent,\n  tileIsEmptyOrOccupiedByOpponent,\n} from './GeneralRules'\n\n// Rules to move the Bishops\nexport const bishopMove = (\n  initialPosition: Position,\n  desiredPosition: Position,\n  team: TeamType,\n  boardState: Piece[]\n): boolean => {\n  // Movement and Attack Logic for Bishop\n  for (let i = 1; i < 11; i++) {\n    // Top right movement\n    if (\n      desiredPosition.x > initialPosition.x &&\n      desiredPosition.y > initialPosition.y\n    ) {\n      let passedPosition = new Position(\n        initialPosition.x + i,\n        initialPosition.y + i\n      )\n      //Check if the tile is the destination tile\n      if (passedPosition.samePosition(desiredPosition)) {\n        //Dealing with destination tile\n        if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true\n        }\n      } else {\n        //Dealing with passing tile\n        if (tileIsOccupied(passedPosition, boardState)) {\n          break\n        }\n      }\n    }\n\n    // Top left movement\n    if (\n      desiredPosition.x < initialPosition.x &&\n      desiredPosition.y > initialPosition.y\n    ) {\n      let passedPosition = new Position(\n        initialPosition.x - i,\n        initialPosition.y + i\n      )\n      if (passedPosition.samePosition(desiredPosition)) {\n        if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true\n        }\n      } else {\n        if (tileIsOccupied(passedPosition, boardState)) {\n          break\n        }\n      }\n    }\n\n    // Bottom right movement\n    if (\n      desiredPosition.x > initialPosition.x &&\n      desiredPosition.y < initialPosition.y\n    ) {\n      let passedPosition = new Position(\n        initialPosition.x + i,\n        initialPosition.y - i\n      )\n      if (passedPosition.samePosition(desiredPosition)) {\n        if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true\n        }\n      } else {\n        if (tileIsOccupied(passedPosition, boardState)) {\n          break\n        }\n      }\n    }\n\n    // Bottom left movement\n    if (\n      desiredPosition.x < initialPosition.x &&\n      desiredPosition.y < initialPosition.y\n    ) {\n      let passedPosition = new Position(\n        initialPosition.x - i,\n        initialPosition.y - i\n      )\n      if (passedPosition.samePosition(desiredPosition)) {\n        if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true\n        }\n      } else {\n        if (tileIsOccupied(passedPosition, boardState)) {\n          break\n        }\n      }\n    }\n  }\n\n  return false\n}\n\n// Checking possible moves for the Bishops to highlight the grids\nexport const getPossibleBishopMoves = (\n  bishop: Piece,\n  boardState: Piece[]\n): Position[] => {\n  const possibleMoves: Position[] = []\n\n  // Upper right movement\n  for (let i = 1; i < 11; i++) {\n    const destination = new Position(\n      bishop.position.x + i,\n      bishop.position.y + i\n    )\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, bishop.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Bottom right movement\n  for (let i = 1; i < 11; i++) {\n    const destination = new Position(\n      bishop.position.x + i,\n      bishop.position.y - i\n    )\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, bishop.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Bottom left movement\n  for (let i = 1; i < 11; i++) {\n    const destination = new Position(\n      bishop.position.x - i,\n      bishop.position.y - i\n    )\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, bishop.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Top left movement\n  for (let i = 1; i < 11; i++) {\n    const destination = new Position(\n      bishop.position.x - i,\n      bishop.position.y + i\n    )\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, bishop.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  return possibleMoves\n}\n","import { Piece, Position } from '../models'\nimport { TeamType } from '../Types'\nimport {\n  tileIsOccupied,\n  tileIsOccupiedByOpponent,\n  tileIsEmptyOrOccupiedByOpponent,\n} from './GeneralRules'\n\n// Rules to move the Rooks\nexport const rookMove = (\n  initialPosition: Position,\n  desiredPosition: Position,\n  team: TeamType,\n  boardState: Piece[]\n): boolean => {\n  // Vertical Movement\n  if (initialPosition.x === desiredPosition.x) {\n    for (let i = 1; i < 14; i++) {\n      let multiplier = desiredPosition.y < initialPosition.y ? -1 : 1\n\n      let passedPosition = new Position(\n        initialPosition.x,\n        initialPosition.y + i * multiplier\n      )\n      if (passedPosition.samePosition(desiredPosition)) {\n        if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true\n        }\n      } else {\n        if (tileIsOccupied(passedPosition, boardState)) {\n          break\n        }\n      }\n    }\n  }\n\n  // Horizontal Movement\n  if (initialPosition.y === desiredPosition.y) {\n    for (let i = 1; i < 14; i++) {\n      let multiplier = desiredPosition.x < initialPosition.x ? -1 : 1\n\n      let passedPosition = new Position(\n        initialPosition.x + i * multiplier,\n        initialPosition.y\n      )\n      if (passedPosition.samePosition(desiredPosition)) {\n        if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true\n        }\n      } else {\n        if (tileIsOccupied(passedPosition, boardState)) {\n          break\n        }\n      }\n    }\n  }\n\n  return false\n}\n\n// Checking possible moves for the Rooks to highlight the grids\nexport const getPossibleRookMoves = (\n  rook: Piece,\n  boardState: Piece[]\n): Position[] => {\n  const possibleMoves: Position[] = []\n\n  // Top movement\n  for (let i = 1; i < 14; i++) {\n    // Stop checking if move is outside of the board\n    if (rook.position.x < 3 && rook.position.y + i > 10) break\n    if (rook.position.x > 10 && rook.position.y + i > 10) break\n\n    const destination = new Position(rook.position.x, rook.position.y + i)\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, rook.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Bottom movement\n  for (let i = 1; i < 14; i++) {\n    // Stop checking if move is outside of the board\n    if (rook.position.x < 3 && rook.position.y - i < 3) break\n    if (rook.position.x > 10 && rook.position.y - i < 3) break\n\n    const destination = new Position(rook.position.x, rook.position.y - i)\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, rook.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Left movement\n  for (let i = 1; i < 14; i++) {\n    // Stop checking if move is outside of the board\n    if (rook.position.y < 3 && rook.position.x - i < 3) break\n    if (rook.position.y > 10 && rook.position.x - i < 3) break\n\n    const destination = new Position(rook.position.x - i, rook.position.y)\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, rook.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Right movement\n  for (let i = 1; i < 14; i++) {\n    // Stop checking if move is outside of the board\n    if (rook.position.y < 3 && rook.position.x + i > 10) break\n    if (rook.position.y > 10 && rook.position.x + i > 10) break\n\n    const destination = new Position(rook.position.x + i, rook.position.y)\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, rook.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  return possibleMoves\n}\n","import { Piece, Position } from '../models'\nimport { TeamType } from '../Types'\nimport {\n  tileIsOccupied,\n  tileIsOccupiedByOpponent,\n  tileIsEmptyOrOccupiedByOpponent,\n} from './GeneralRules'\n\n// Rules to move the Queens\nexport const queenMove = (\n  initialPosition: Position,\n  desiredPosition: Position,\n  team: TeamType,\n  boardState: Piece[]\n): boolean => {\n  // Checking for queen moves\n  for (let i = 1; i < 14; i++) {\n    let multiplierX =\n      desiredPosition.x < initialPosition.x\n        ? -1\n        : desiredPosition.x > initialPosition.x\n        ? 1\n        : 0\n    let multiplierY =\n      desiredPosition.y < initialPosition.y\n        ? -1\n        : desiredPosition.y > initialPosition.y\n        ? 1\n        : 0\n\n    let passedPosition = new Position(\n      initialPosition.x + i * multiplierX,\n      initialPosition.y + i * multiplierY\n    )\n\n    // Checking if the tile is occupied/empty\n    if (passedPosition.samePosition(desiredPosition)) {\n      if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n        return true\n      }\n    } else {\n      if (tileIsOccupied(passedPosition, boardState)) {\n        break\n      }\n    }\n  }\n\n  return false\n}\n\n// Checking possible moves for the Queens to highlight the grids\nexport const getPossibleQueenMoves = (\n  queen: Piece,\n  boardState: Piece[]\n): Position[] => {\n  const possibleMoves: Position[] = []\n\n  // Top movement\n  for (let i = 1; i < 14; i++) {\n    const destination = new Position(queen.position.x, queen.position.y + i)\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, queen.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Bottom movement\n  for (let i = 1; i < 14; i++) {\n    const destination = new Position(queen.position.x, queen.position.y - i)\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, queen.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Left movement\n  for (let i = 1; i < 14; i++) {\n    const destination = new Position(queen.position.x - i, queen.position.y)\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, queen.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Right movement\n  for (let i = 1; i < 14; i++) {\n    const destination = new Position(queen.position.x + i, queen.position.y)\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, queen.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Upper right movement\n  for (let i = 1; i < 11; i++) {\n    const destination = new Position(queen.position.x + i, queen.position.y + i)\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, queen.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Bottom right movement\n  for (let i = 1; i < 11; i++) {\n    const destination = new Position(queen.position.x + i, queen.position.y - i)\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, queen.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Bottom left movement\n  for (let i = 1; i < 11; i++) {\n    const destination = new Position(queen.position.x - i, queen.position.y - i)\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, queen.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Top left movement\n  for (let i = 1; i < 11; i++) {\n    const destination = new Position(queen.position.x - i, queen.position.y + i)\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, queen.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  return possibleMoves\n}\n","import { Piece, Position } from '../models'\nimport { TeamType } from '../Types'\nimport {\n  tileIsOccupied,\n  tileIsOccupiedByOpponent,\n  tileIsEmptyOrOccupiedByOpponent,\n} from './GeneralRules'\n\n// Rules to move the Kings\nexport const kingMove = (\n  initialPosition: Position,\n  desiredPosition: Position,\n  team: TeamType,\n  boardState: Piece[]\n): boolean => {\n  // Checking for king moves\n  for (let i = 1; i < 2; i++) {\n    let multiplierX =\n      desiredPosition.x < initialPosition.x\n        ? -1\n        : desiredPosition.x > initialPosition.x\n        ? 1\n        : 0\n    let multiplierY =\n      desiredPosition.y < initialPosition.y\n        ? -1\n        : desiredPosition.y > initialPosition.y\n        ? 1\n        : 0\n\n    let passedPosition = new Position(\n      initialPosition.x + i * multiplierX,\n      initialPosition.y + i * multiplierY\n    )\n\n    // Checking if the tile is occupied/empty\n    if (passedPosition.samePosition(desiredPosition)) {\n      if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n        return true\n      }\n    } else {\n      if (tileIsOccupied(passedPosition, boardState)) {\n        break\n      }\n    }\n  }\n\n  return false\n}\n\n// Checking possible moves for the Kings to highlight the grids\nexport const getPossibleKingMoves = (\n  king: Piece,\n  boardState: Piece[]\n): Position[] => {\n  const possibleMoves: Position[] = []\n\n  // Top movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x, king.position.y + i)\n\n    // If the move is outside of the board don't add it\n    if (\n      (destination.x < 3 && destination.y < 3) ||\n      (destination.x > 10 && destination.y < 3) ||\n      (destination.x > 10 && destination.y > 10) ||\n      (destination.x < 3 && destination.y > 10) ||\n      destination.x < 0 ||\n      destination.x > 13 ||\n      destination.y < 0 ||\n      destination.y > 13\n    ) {\n      break\n    }\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, king.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Bottom movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x, king.position.y - i)\n\n    // If the move is outside of the board don't add it\n    if (\n      (destination.x < 3 && destination.y < 3) ||\n      (destination.x > 10 && destination.y < 3) ||\n      (destination.x > 10 && destination.y > 10) ||\n      (destination.x < 3 && destination.y > 10) ||\n      destination.x < 0 ||\n      destination.x > 13 ||\n      destination.y < 0 ||\n      destination.y > 13\n    ) {\n      break\n    }\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, king.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Left movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y)\n\n    // If the move is outside of the board don't add it\n    if (\n      (destination.x < 3 && destination.y < 3) ||\n      (destination.x > 10 && destination.y < 3) ||\n      (destination.x > 10 && destination.y > 10) ||\n      (destination.x < 3 && destination.y > 10) ||\n      destination.x < 0 ||\n      destination.x > 13 ||\n      destination.y < 0 ||\n      destination.y > 13\n    ) {\n      break\n    }\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, king.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Right movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y)\n\n    // If the move is outside of the board don't add it\n    if (\n      (destination.x < 3 && destination.y < 3) ||\n      (destination.x > 10 && destination.y < 3) ||\n      (destination.x > 10 && destination.y > 10) ||\n      (destination.x < 3 && destination.y > 10) ||\n      destination.x < 0 ||\n      destination.x > 13 ||\n      destination.y < 0 ||\n      destination.y > 13\n    ) {\n      break\n    }\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, king.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Upper right movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y + i)\n\n    // If the move is outside of the board don't add it\n    if (\n      (destination.x < 3 && destination.y < 3) ||\n      (destination.x > 10 && destination.y < 3) ||\n      (destination.x > 10 && destination.y > 10) ||\n      (destination.x < 3 && destination.y > 10) ||\n      destination.x < 0 ||\n      destination.x > 13 ||\n      destination.y < 0 ||\n      destination.y > 13\n    ) {\n      break\n    }\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, king.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Bottom right movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y - i)\n\n    // If the move is outside of the board don't add it\n    if (\n      (destination.x < 3 && destination.y < 3) ||\n      (destination.x > 10 && destination.y < 3) ||\n      (destination.x > 10 && destination.y > 10) ||\n      (destination.x < 3 && destination.y > 10) ||\n      destination.x < 0 ||\n      destination.x > 13 ||\n      destination.y < 0 ||\n      destination.y > 13\n    ) {\n      break\n    }\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, king.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Bottom left movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y - i)\n\n    // If the move is outside of the board don't add it\n    if (\n      (destination.x < 3 && destination.y < 3) ||\n      (destination.x > 10 && destination.y < 3) ||\n      (destination.x > 10 && destination.y > 10) ||\n      (destination.x < 3 && destination.y > 10) ||\n      destination.x < 0 ||\n      destination.x > 13 ||\n      destination.y < 0 ||\n      destination.y > 13\n    ) {\n      break\n    }\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, king.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  // Top left movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y + i)\n\n    // If the move is outside of the board don't add it\n    if (\n      (destination.x < 3 && destination.y < 3) ||\n      (destination.x > 10 && destination.y < 3) ||\n      (destination.x > 10 && destination.y > 10) ||\n      (destination.x < 3 && destination.y > 10) ||\n      destination.x < 0 ||\n      destination.x > 13 ||\n      destination.y < 0 ||\n      destination.y > 13\n    ) {\n      break\n    }\n\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination)\n    } else if (tileIsOccupiedByOpponent(destination, boardState, king.team)) {\n      possibleMoves.push(destination)\n      break\n    } else {\n      break\n    }\n  }\n\n  return possibleMoves\n}\n\n// Getting the castling moves for the king\n// In this method, enemy moves have already been calculated\nexport const getCastlingMoves = (\n  king: Piece,\n  boardState: Piece[]\n): Position[] => {\n  const possibleMoves: Position[] = []\n\n  if (king.hasMoved) return possibleMoves\n\n  // Get unmoved rooks from the king's team\n  const rooks = boardState.filter(\n    (p) => p.isRook && p.team === king.team && !p.hasMoved\n  )\n\n  // For red and yellow rooks\n  // Loop through the rooks\n  for (const rook of rooks) {\n    // Determine if we have to go to right or left\n    const direction =\n      rook.team === TeamType.RED || rook.team === TeamType.YELLOW\n        ? rook.position.x - king.position.x > 0\n          ? 1\n          : -1\n        : rook.position.y - king.position.y > 0\n        ? 1\n        : -1\n\n    const adjacentPosition = king.position.clone()\n    if (king.team === TeamType.RED || king.team === TeamType.YELLOW) {\n      adjacentPosition.x += direction\n    } else {\n      adjacentPosition.y += direction\n    }\n\n    if (!rook.possibleMoves?.some((m) => m.samePosition(adjacentPosition)))\n      continue\n\n    const concerningTiles =\n      king.team === TeamType.RED || king.team === TeamType.YELLOW\n        ? rook.possibleMoves.filter((m) => m.y === king.position.y)\n        : rook.possibleMoves.filter((m) => m.x === king.position.x)\n\n    // Filter out the enemy\n    const enemyPieces = boardState.filter((p) => p.team !== king.team)\n\n    let valid = true\n\n    // Looping through all enemy pieces\n    for (const enemy of enemyPieces) {\n      // Checking if the concerned tiles for castling has the same position\n      // as the possible moves of the enemy\n      for (const move of enemy.possibleMoves) {\n        if (concerningTiles.some((t) => t.samePosition(move))) {\n          valid = false\n        }\n\n        if (!valid) break\n      }\n\n      if (!valid) break\n    }\n\n    if (!valid) continue\n\n    // We now want to add it as a possible move\n    possibleMoves.push(rook.position.clone())\n  }\n\n  return possibleMoves\n}\n","import { Piece } from './Piece'\nimport { Position } from './Position'\nimport { PieceType, TeamType } from '../Types'\nimport {\n  getPossibleBishopMoves,\n  getPossibleKingMoves,\n  getPossibleKnightMoves,\n  getPossiblePawnMoves,\n  getPossibleQueenMoves,\n  getPossibleRookMoves,\n  getCastlingMoves,\n} from '../rules'\n\n// Exporting the board class\nexport class Board {\n  pieces: Piece[]\n  totalTurns: number\n  gameOver: boolean = false\n  loseOrder: TeamType[] = []\n  currentTeam: TeamType\n\n  // Defining the constructor\n  constructor(\n    pieces: Piece[],\n    totalTurns: number,\n    currentTeam = TeamType.RED,\n    loseOrder: TeamType[] = []\n  ) {\n    this.pieces = pieces\n    this.totalTurns = totalTurns\n    this.currentTeam = currentTeam\n    this.loseOrder = loseOrder\n  }\n\n  // Red -> Blue -> Yellow -> Green\n  // Red plays first\n  // in case of checkmate, call getNextTeam before pushing to loseOrder\n  getNextTeam(): TeamType {\n    let teams = [\n      TeamType.RED,\n      TeamType.BLUE,\n      TeamType.YELLOW,\n      TeamType.GREEN,\n    ].filter((t) => !this.loseOrder.includes(t))\n\n    return teams[(teams.indexOf(this.currentTeam) + 1) % teams.length]\n  }\n\n  calculateAllMoves() {\n    // For each piece, calculate the possible moves\n    for (const piece of this.pieces) {\n      piece.possibleMoves = this.getValidMoves(piece, this.pieces)\n    }\n\n    // Calculate castling moves\n    for (const king of this.pieces.filter((p) => p.isKing)) {\n      king.possibleMoves = [\n        ...king.possibleMoves,\n        ...getCastlingMoves(king, this.pieces),\n      ]\n    }\n\n    // Checking if the moves of king are valid\n    this.checkCurrentTeamMoves()\n\n    // Removing the possible moves of the team\n    //that does not have its chance at the moment\n    for (const piece of this.pieces.filter(\n      (p) => p.team !== this.currentTeam\n    )) {\n      piece.possibleMoves = []\n    }\n\n    //Checking if the playing team still has moves left, else checkmate\n    if (\n      this.pieces\n        .filter((p) => p.team === this.currentTeam)\n        .some((p) => p.possibleMoves.length > 0)\n    )\n      return\n\n    let lostTeam = this.currentTeam\n\n    this.currentTeam = this.getNextTeam()\n    this.loseOrder.push(lostTeam)\n\n    if (this.loseOrder.length === 3) {\n      this.gameOver = true\n    } else {\n      this.calculateAllMoves()\n    }\n  }\n\n  checkCurrentTeamMoves() {\n    // Looping through all the current team's pieces\n    for (const piece of this.pieces.filter(\n      (p) => p.team === this.currentTeam\n    )) {\n      // Simulate all the piece moves\n      for (const move of piece.possibleMoves) {\n        const simulatedBoard = this.clone()\n\n        // Remove the piece at the destination position\n        simulatedBoard.pieces = simulatedBoard.pieces.filter(\n          (p) => !p.samePosition(move)\n        )\n\n        // Get the pieces of the cloned board\n        const clonedPiece = simulatedBoard.pieces.find((p) =>\n          p.samePiecePosition(piece)\n        )!\n        clonedPiece.position = move.clone()\n\n        // Get the king of the cloned board\n        const clonedKing = simulatedBoard.pieces.find(\n          (p) => p.isKing && p.team === simulatedBoard.currentTeam\n        )!\n\n        // Loop through all enemy pieces, update their possible moves\n        // And check if the current team's king will be in danger\n        for (const enemy of simulatedBoard.pieces.filter(\n          (p) => p.team !== simulatedBoard.currentTeam\n        )) {\n          enemy.possibleMoves = simulatedBoard.getValidMoves(\n            enemy,\n            simulatedBoard.pieces\n          )\n\n          if (enemy.isPawn) {\n            if (\n              enemy.possibleMoves.some(\n                (m) =>\n                  m.x !== enemy.position.x &&\n                  m.samePosition(clonedKing.position)\n              )\n            ) {\n              piece.possibleMoves = piece.possibleMoves?.filter(\n                (m) => !m.samePosition(move)\n              )\n            }\n          } else {\n            if (\n              enemy.possibleMoves.some((m) =>\n                m.samePosition(clonedKing.position)\n              )\n            ) {\n              piece.possibleMoves = piece.possibleMoves?.filter(\n                (m) => !m.samePosition(move)\n              )\n            }\n          }\n        }\n      }\n    }\n  }\n\n  get isChecked() {\n    const simulatedBoard = this.clone()\n    const king = simulatedBoard.pieces.find(\n      (p) => p.isKing && p.team === simulatedBoard.currentTeam\n    )!\n\n    return simulatedBoard.pieces\n      .filter((p) => p.team !== simulatedBoard.currentTeam)\n      .some((enemy) =>\n        simulatedBoard\n          .getValidMoves(enemy, simulatedBoard.pieces)\n          .some((m) => m.samePosition(king.position))\n      )\n  }\n\n  // Getting the valid moves of the pieces which is being played\n  getValidMoves(piece: Piece, boardState: Piece[]): Position[] {\n    switch (piece.type) {\n      case PieceType.PAWN:\n        return getPossiblePawnMoves(piece, boardState)\n      case PieceType.KNIGHT:\n        return getPossibleKnightMoves(piece, boardState)\n      case PieceType.BISHOP:\n        return getPossibleBishopMoves(piece, boardState)\n      case PieceType.ROOK:\n        return getPossibleRookMoves(piece, boardState)\n      case PieceType.QUEEN:\n        return getPossibleQueenMoves(piece, boardState)\n      case PieceType.KING:\n        return getPossibleKingMoves(piece, boardState)\n      default:\n        return []\n    }\n  }\n\n  playMove(playedPiece: Piece, destination: Position) {\n    const destinationPiece = this.pieces.find((p) =>\n      p.samePosition(destination)\n    )\n\n    // If castling is played\n    if (\n      playedPiece.isKing &&\n      destinationPiece?.isRook &&\n      destinationPiece.team === playedPiece.team\n    ) {\n      // Deciding the direction of castling for different players\n      const direction =\n        destinationPiece.team === TeamType.RED ||\n        playedPiece.team === TeamType.YELLOW\n          ? destinationPiece.position.x - playedPiece.position.x > 0\n            ? 1\n            : -1\n          : destinationPiece.position.y - playedPiece.position.y > 0\n          ? 1\n          : -1\n\n      // Implementing the direction of castling\n      if (\n        playedPiece.team === TeamType.RED ||\n        playedPiece.team === TeamType.YELLOW\n      ) {\n        const newKingXPosition = playedPiece.position.x + direction * 2\n        this.pieces = this.pieces.map((p) => {\n          if (p.samePiecePosition(playedPiece)) {\n            p.position.x = newKingXPosition\n            p.hasMoved = true\n          } else if (p.samePiecePosition(destinationPiece)) {\n            p.position.x = newKingXPosition - direction\n            p.hasMoved = true\n          }\n\n          return p\n        })\n      } else {\n        const newKingYPosition = playedPiece.position.y + direction * 2\n        this.pieces = this.pieces.map((p) => {\n          if (p.samePiecePosition(playedPiece)) {\n            p.position.y = newKingYPosition\n          } else if (p.samePiecePosition(destinationPiece)) {\n            p.position.y = newKingYPosition - direction\n          }\n\n          return p\n        })\n      }\n      this.totalTurns++\n      this.currentTeam = this.getNextTeam()\n\n      this.calculateAllMoves()\n      return\n    }\n\n    // Updated the pieces position\n    // And if a piece is attacked, removes it\n    this.pieces = this.pieces.reduce((results, piece) => {\n      // Piece that we are currently playing\n      if (piece.samePiecePosition(playedPiece)) {\n        piece.position.x = destination.x\n        piece.position.y = destination.y\n        piece.hasMoved = true\n\n        results.push(piece)\n      } else if (!piece.samePosition(destination)) {\n        results.push(piece)\n      }\n\n      return results\n    }, [] as Piece[])\n\n    this.totalTurns++\n    this.currentTeam = this.getNextTeam()\n\n    this.calculateAllMoves()\n  }\n\n  // Clone function of the board\n  clone(): Board {\n    return new Board(\n      this.pieces.map((p) => p.clone()),\n      this.totalTurns,\n      this.currentTeam,\n      this.loseOrder\n    )\n  }\n}\n","import { PieceType, TeamType } from '../Types'\nimport { Position } from './Position'\n\n// Exporting the piece class\nexport class Piece {\n  image: string\n  position: Position\n  type: PieceType\n  team: TeamType\n  possibleMoves: Position[]\n  hasMoved: boolean\n\n  constructor(\n    position: Position,\n    type: PieceType,\n    team: TeamType,\n    hasMoved: boolean,\n    possibleMoves: Position[] = []\n  ) {\n    const basePath = window.location.hostname === 'localhost' ? 'chessed/' : ''\n\n    this.image = `${basePath}assets/images/${team}${type}.png`\n    this.position = position\n    this.type = type\n    this.team = team\n    this.possibleMoves = possibleMoves\n    this.hasMoved = hasMoved\n  }\n\n  get isPawn(): boolean {\n    return this.type === PieceType.PAWN\n  }\n\n  get isRook(): boolean {\n    return this.type === PieceType.ROOK\n  }\n\n  get isKing(): boolean {\n    return this.type === PieceType.KING\n  }\n\n  // function for same piece position\n  samePiecePosition(otherPiece: Piece): boolean {\n    return this.position.samePosition(otherPiece.position)\n  }\n\n  // function for comparing same position\n  samePosition(otherPosition: Position): boolean {\n    return this.position.samePosition(otherPosition)\n  }\n\n  // cloning piece\n  clone(): Piece {\n    return new Piece(\n      this.position.clone(),\n      this.type,\n      this.team,\n      this.hasMoved,\n      this.possibleMoves?.map((m) => m.clone())\n    )\n  }\n}\n","export class Position {\n  x: number\n  y: number\n\n  constructor(x: number, y: number) {\n    this.x = x\n    this.y = y\n  }\n\n  samePosition(otherPosition: Position): boolean {\n    return this.x === otherPosition.x && this.y === otherPosition.y\n  }\n\n  clone(): Position {\n    return new Position(this.x, this.y)\n  }\n}\n","import React from 'react'\nimport './Tile.css'\n\n// Interface for deciding the types\ninterface Props {\n  image?: string\n  num_i: number\n  num_j: number\n  highlight: boolean\n  teamLost: boolean\n  check: boolean\n}\n\nexport default function Tile({\n  num_i,\n  num_j,\n  image,\n  highlight,\n  teamLost,\n  check,\n}: Props) {\n  const className: string = [\n    'tile',\n    (num_i + num_j) % 2 === 0 && 'dark-tile', // Dark Tiles\n    (num_i + num_j) % 2 !== 0 && 'light-tile', // Light Tiles\n    highlight && 'tile-highlight', // Highlighting the tiles with possible moves\n    image && 'chess-piece-tile', // Highlighting the tiles with attacked chess pieces\n    teamLost && 'piece-dead', // Highlighting the pieces of the lost team\n    check && 'checked', // Highlighting the king if in check\n  ]\n    .filter(Boolean)\n    .join(' ')\n\n  // Useless tiles\n  // Useless tiles are those tiles which are at the corners of the 'squared' chess board\n  if (\n    (num_i < 3 && num_j < 3) ||\n    (num_i > 10 && num_j < 3) ||\n    (num_i > 10 && num_j > 10) ||\n    (num_i < 3 && num_j > 10)\n  ) {\n    return <div className='tile useless'></div>\n  }\n\n  // Chessboard tiles\n  else {\n    return (\n      <div className={className}>\n        {image && (\n          <div\n            style={{ backgroundImage: `url(${image})` }}\n            className='chess-piece'\n          ></div>\n        )}\n      </div>\n    )\n  }\n}\n","import { Board, Piece, Position } from './models'\nimport { PieceType, TeamType } from './Types'\n\n// Axes\nexport const VERTICAL_AXIS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\nexport const HORIZONTAL_AXIS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n\n// Grid Size\nexport const GRID_SIZE = 50\n\n// InitialBoardState\nexport const initialBoard: Board = new Board(\n  [\n    // Red Pieces\n    new Piece(new Position(3, 0), PieceType.ROOK, TeamType.RED, false),\n    new Piece(new Position(4, 0), PieceType.KNIGHT, TeamType.RED, false),\n    new Piece(new Position(5, 0), PieceType.BISHOP, TeamType.RED, false),\n    new Piece(new Position(6, 0), PieceType.QUEEN, TeamType.RED, false),\n    new Piece(new Position(7, 0), PieceType.KING, TeamType.RED, false),\n    new Piece(new Position(8, 0), PieceType.BISHOP, TeamType.RED, false),\n    new Piece(new Position(9, 0), PieceType.KNIGHT, TeamType.RED, false),\n    new Piece(new Position(10, 0), PieceType.ROOK, TeamType.RED, false),\n    // Pawns\n    new Piece(new Position(3, 1), PieceType.PAWN, TeamType.RED, false),\n    new Piece(new Position(4, 1), PieceType.PAWN, TeamType.RED, false),\n    new Piece(new Position(5, 1), PieceType.PAWN, TeamType.RED, false),\n    new Piece(new Position(6, 1), PieceType.PAWN, TeamType.RED, false),\n    new Piece(new Position(7, 1), PieceType.PAWN, TeamType.RED, false),\n    new Piece(new Position(8, 1), PieceType.PAWN, TeamType.RED, false),\n    new Piece(new Position(9, 1), PieceType.PAWN, TeamType.RED, false),\n    new Piece(new Position(10, 1), PieceType.PAWN, TeamType.RED, false),\n\n    // Yellow Pieces\n    new Piece(new Position(3, 13), PieceType.ROOK, TeamType.YELLOW, false),\n    new Piece(new Position(4, 13), PieceType.KNIGHT, TeamType.YELLOW, false),\n    new Piece(new Position(5, 13), PieceType.BISHOP, TeamType.YELLOW, false),\n    new Piece(new Position(6, 13), PieceType.KING, TeamType.YELLOW, false),\n    new Piece(new Position(7, 13), PieceType.QUEEN, TeamType.YELLOW, false),\n    new Piece(new Position(8, 13), PieceType.BISHOP, TeamType.YELLOW, false),\n    new Piece(new Position(9, 13), PieceType.KNIGHT, TeamType.YELLOW, false),\n    new Piece(new Position(10, 13), PieceType.ROOK, TeamType.YELLOW, false),\n    // Pawns\n    new Piece(new Position(3, 12), PieceType.PAWN, TeamType.YELLOW, false),\n    new Piece(new Position(4, 12), PieceType.PAWN, TeamType.YELLOW, false),\n    new Piece(new Position(5, 12), PieceType.PAWN, TeamType.YELLOW, false),\n    new Piece(new Position(6, 12), PieceType.PAWN, TeamType.YELLOW, false),\n    new Piece(new Position(7, 12), PieceType.PAWN, TeamType.YELLOW, false),\n    new Piece(new Position(8, 12), PieceType.PAWN, TeamType.YELLOW, false),\n    new Piece(new Position(9, 12), PieceType.PAWN, TeamType.YELLOW, false),\n    new Piece(new Position(10, 12), PieceType.PAWN, TeamType.YELLOW, false),\n\n    // BLUE Pieces\n    new Piece(new Position(0, 3), PieceType.ROOK, TeamType.BLUE, false),\n    new Piece(new Position(0, 4), PieceType.KNIGHT, TeamType.BLUE, false),\n    new Piece(new Position(0, 5), PieceType.BISHOP, TeamType.BLUE, false),\n    new Piece(new Position(0, 6), PieceType.QUEEN, TeamType.BLUE, false),\n    new Piece(new Position(0, 7), PieceType.KING, TeamType.BLUE, false),\n    new Piece(new Position(0, 8), PieceType.BISHOP, TeamType.BLUE, false),\n    new Piece(new Position(0, 9), PieceType.KNIGHT, TeamType.BLUE, false),\n    new Piece(new Position(0, 10), PieceType.ROOK, TeamType.BLUE, false),\n    // Pawns\n    new Piece(new Position(1, 3), PieceType.PAWN, TeamType.BLUE, false),\n    new Piece(new Position(1, 4), PieceType.PAWN, TeamType.BLUE, false),\n    new Piece(new Position(1, 5), PieceType.PAWN, TeamType.BLUE, false),\n    new Piece(new Position(1, 6), PieceType.PAWN, TeamType.BLUE, false),\n    new Piece(new Position(1, 7), PieceType.PAWN, TeamType.BLUE, false),\n    new Piece(new Position(1, 8), PieceType.PAWN, TeamType.BLUE, false),\n    new Piece(new Position(1, 9), PieceType.PAWN, TeamType.BLUE, false),\n    new Piece(new Position(1, 10), PieceType.PAWN, TeamType.BLUE, false),\n\n    // Green Pieces\n    new Piece(new Position(13, 3), PieceType.ROOK, TeamType.GREEN, false),\n    new Piece(new Position(13, 4), PieceType.KNIGHT, TeamType.GREEN, false),\n    new Piece(new Position(13, 5), PieceType.BISHOP, TeamType.GREEN, false),\n    new Piece(new Position(13, 6), PieceType.KING, TeamType.GREEN, false),\n    new Piece(new Position(13, 7), PieceType.QUEEN, TeamType.GREEN, false),\n    new Piece(new Position(13, 8), PieceType.BISHOP, TeamType.GREEN, false),\n    new Piece(new Position(13, 9), PieceType.KNIGHT, TeamType.GREEN, false),\n    new Piece(new Position(13, 10), PieceType.ROOK, TeamType.GREEN, false),\n    // Pawns\n    new Piece(new Position(12, 3), PieceType.PAWN, TeamType.GREEN, false),\n    new Piece(new Position(12, 4), PieceType.PAWN, TeamType.GREEN, false),\n    new Piece(new Position(12, 5), PieceType.PAWN, TeamType.GREEN, false),\n    new Piece(new Position(12, 6), PieceType.PAWN, TeamType.GREEN, false),\n    new Piece(new Position(12, 7), PieceType.PAWN, TeamType.GREEN, false),\n    new Piece(new Position(12, 8), PieceType.PAWN, TeamType.GREEN, false),\n    new Piece(new Position(12, 9), PieceType.PAWN, TeamType.GREEN, false),\n    new Piece(new Position(12, 10), PieceType.PAWN, TeamType.GREEN, false),\n  ],\n  0\n)\n\ninitialBoard.calculateAllMoves()\n","import './Chessboard.css'\nimport PlayerName from '../PlayerName/PlayerName'\nimport { Piece, Position } from '../../models'\nimport Tile from '../Tile/Tile'\nimport { useRef, useState } from 'react'\nimport { VERTICAL_AXIS, HORIZONTAL_AXIS, GRID_SIZE } from '../../Constants'\nimport { PieceType, TeamType } from '../../Types'\nimport React from 'react'\n// Interface deciding the types\ninterface Props {\n  playMove: (piece: Piece, position: Position) => boolean\n  pieces: Piece[]\n  whoseTurn: TeamType\n  loseOrder: TeamType[]\n  isChecked: boolean\n}\n\nexport default function Chessboard({\n  playMove,\n  pieces,\n  whoseTurn,\n  loseOrder,\n  isChecked,\n}: Props) {\n  // Declaring Constants\n  const [activePiece, setActivePiece] = useState<HTMLElement | null>(null)\n  const [grabPosition, setGrabPosition] = useState<Position>(\n    new Position(-1, -1)\n  )\n  const [isClicked, setIsClicked] = useState<boolean>(false)\n  const chessboardRef = useRef<HTMLDivElement>(null)\n  // Function when player grabs a  piece\n  function grabPiece(e: React.MouseEvent) {\n    // Grabbing the pieces off the chessboard\n    const chessboard = chessboardRef.current\n    const element = e.target as HTMLElement\n\n    if (element.classList.contains('chess-piece') && chessboard) {\n      const grabX = Math.floor((e.clientX - chessboard.offsetLeft) / GRID_SIZE)\n      const grabY = Math.abs(\n        Math.abs(\n          Math.ceil((e.clientY - chessboard.offsetTop - 700) / GRID_SIZE)\n        )\n      )\n\n      setGrabPosition(new Position(grabX, grabY))\n\n      const x = e.clientX - GRID_SIZE / 2\n      const y = e.clientY - GRID_SIZE / 2\n\n      element.style.position = 'absolute'\n      element.style.left = `${x}px`\n      element.style.top = `${y}px`\n      element.style.zIndex = '10'\n\n      setActivePiece(element)\n      setIsClicked(false)\n      document.body.style.userSelect = 'none'\n    }\n  }\n\n  // Function when player clicks a piece\n  function clickPiece(e: React.MouseEvent) {\n    const chessboard = chessboardRef.current\n    const element = e.target as HTMLElement\n\n    if (element.classList.contains('chess-piece') && chessboard) {\n      const grabX = Math.floor((e.clientX - chessboard.offsetLeft) / GRID_SIZE)\n      const grabY = Math.abs(\n        Math.abs(\n          Math.ceil((e.clientY - chessboard.offsetTop - 700) / GRID_SIZE)\n        )\n      )\n\n      setGrabPosition(new Position(grabX, grabY))\n      setActivePiece(element)\n      setIsClicked(true)\n    }\n  }\n\n  // Function when player tries to move a piece\n  function movePiece(e: React.MouseEvent) {\n    const chessboard = chessboardRef.current\n\n    if (activePiece && chessboard) {\n      // Declaring constants for restricting the pieces\n      const leftX = chessboard.offsetLeft - 4\n      const midleftX =\n        chessboard.offsetLeft + (chessboard.clientWidth / 14) * 3 - 4\n      const topY = chessboard.offsetTop - 4\n      const midtopY =\n        chessboard.offsetTop + (chessboard.clientHeight / 14) * 3 - 4\n      const rightX = chessboard.offsetLeft + chessboard.clientWidth - 46\n      const midrightX =\n        chessboard.offsetLeft -\n        (chessboard.clientWidth / 14) * 3 +\n        chessboard.clientWidth -\n        46\n      const bottomY = chessboard.offsetTop + chessboard.clientHeight - 46\n      const midbottomY =\n        chessboard.offsetTop -\n        (chessboard.clientHeight / 14) * 3 +\n        chessboard.clientHeight -\n        46\n      const x = e.clientX - GRID_SIZE / 2\n      const y = e.clientY - GRID_SIZE / 2\n      activePiece.style.position = 'absolute'\n\n      // Restricting the x position\n      if (x < leftX) {\n        activePiece.style.left = `${leftX}px`\n      } else if (x > rightX) {\n        activePiece.style.left = `${rightX}px`\n      } else {\n        activePiece.style.left = `${x}px`\n      }\n\n      // Restricting the y position\n      if (y < topY) {\n        activePiece.style.top = `${topY}px`\n      } else if (y > bottomY) {\n        activePiece.style.top = `${bottomY}px`\n      } else {\n        activePiece.style.top = `${y}px`\n      }\n\n      // Restricting the cutout portions\n      if ((x < midleftX && y > midbottomY) || (x < midleftX && y < midtopY)) {\n        activePiece.style.left = `${midleftX}px`\n      } else if (\n        (x > midrightX && y > midbottomY) ||\n        (x > midrightX && y < midtopY)\n      ) {\n        activePiece.style.left = `${midrightX}px`\n      }\n    }\n  }\n\n  // Function when player drops a piece\n  function dropPiece(e: React.MouseEvent) {\n    const chessboard = chessboardRef.current\n    // Dropping the pieces on the right grid\n    if (activePiece && chessboard) {\n      const x = Math.floor((e.clientX - chessboard.offsetLeft) / GRID_SIZE)\n      const y = Math.abs(\n        Math.ceil((e.clientY - chessboard.offsetTop - 700) / GRID_SIZE)\n      )\n\n      const currentPiece = pieces.find((p) => p.samePosition(grabPosition))\n\n      if (currentPiece) {\n        var success = playMove(currentPiece.clone(), new Position(x, y))\n\n        if (!success) {\n          // Resets the piece position\n          activePiece.style.position = 'static'\n          activePiece.style.removeProperty('top')\n          activePiece.style.removeProperty('left')\n          activePiece.style.removeProperty('z-index')\n        }\n      }\n\n      setActivePiece(null)\n      document.body.style.userSelect = 'auto'\n    }\n  }\n  // Setting the four player chessboard\n  let board = []\n\n  for (let j = VERTICAL_AXIS.length - 1; j >= 0; j--) {\n    for (let i = 0; i < HORIZONTAL_AXIS.length; i++) {\n      const num_i = i\n      const num_j = j\n      const piece = pieces.find((p) => p.samePosition(new Position(i, j)))\n      let image = piece ? piece.image : undefined\n\n      let currentPiece =\n        activePiece != null\n          ? pieces.find((p) => p.samePosition(grabPosition))\n          : undefined\n\n      // For highlighting the attacked pieces\n      let highlight = currentPiece?.possibleMoves\n        ? currentPiece.possibleMoves.some((p) =>\n            p.samePosition(new Position(i, j))\n          )\n        : false\n\n      board.push(\n        <Tile\n          key={`${i},${j}`}\n          num_i={num_i}\n          num_j={num_j}\n          image={image}\n          highlight={highlight}\n          teamLost={piece ? loseOrder.includes(piece.team) : false}\n          check={\n            isChecked &&\n            piece?.type === PieceType.KING &&\n            piece?.team === whoseTurn\n          }\n        />\n      )\n    }\n  }\n  return (\n    <>\n      <div\n        onMouseMove={(e) => {\n          if (!isClicked) {\n            movePiece(e)\n          }\n        }}\n        onMouseDown={(e) => grabPiece(e)}\n        onClick={(e) => clickPiece(e)}\n        onMouseUp={(e) => dropPiece(e)}\n        id='chessboard'\n        ref={chessboardRef}\n      >\n        {board}\n        <PlayerName whoseTurn={whoseTurn} lostTeams={loseOrder} />\n      </div>\n    </>\n  )\n}\n","import { Board } from '../../models/Board'\nimport Chessboard from '../Chessboard/Chessboard'\nimport { initialBoard } from '../../Constants'\nimport { PieceType, TeamType } from '../../Types'\nimport { Piece, Position } from '../../models'\nimport { useRef, useState } from 'react'\nimport React from 'react'\nexport default function Arbiter() {\n  // Declaring the constants\n  const [board, setBoard] = useState<Board>(initialBoard.clone())\n  const [promotionPawn, setPromotionPawn] = useState<Piece>()\n  const modalRef = useRef<HTMLDivElement>(null)\n  const checkmateModalRef = useRef<HTMLDivElement>(null)\n\n  // Checks for production/development\n  const basePath = window.location.hostname === 'localhost' ? '/chessed' : ''\n\n  // Function for playing a move\n  function playMove(playedPiece: Piece, destination: Position): boolean {\n    // Checking if the correct team has played the piece\n    if (playedPiece.team !== board.currentTeam) return false\n\n    // Checking for valid move\n    const validMove = playedPiece.possibleMoves?.some((m) =>\n      m.samePosition(destination)\n    )\n\n    if (!validMove) return false\n\n    // playMove modifies the board state\n    setBoard((board) => {\n      const clonedBoard = board.clone()\n\n      // Playing a move\n      clonedBoard.playMove(playedPiece, destination)\n\n      if (clonedBoard.gameOver) {\n        checkmateModalRef.current?.classList.remove('hidden')\n      }\n\n      return clonedBoard\n    })\n\n    // Checking if a pawn is promoted\n    if (playedPiece.isPawn) {\n      if (\n        (playedPiece.team === TeamType.RED && destination.y === 7) ||\n        (playedPiece.team === TeamType.YELLOW && destination.y === 6) ||\n        (playedPiece.team === TeamType.BLUE && destination.x === 7) ||\n        (playedPiece.team === TeamType.GREEN && destination.x === 6)\n      ) {\n        modalRef.current?.classList.remove('hidden')\n        setPromotionPawn((previousPromotionPawn) => {\n          const clonedPlayedPiece = playedPiece.clone()\n          clonedPlayedPiece.position = destination.clone()\n          return clonedPlayedPiece\n        })\n      }\n    }\n    return true\n  }\n\n  // Function to promote a pawn to the desired piece\n  function promotePawn(pieceType: PieceType) {\n    if (promotionPawn === undefined) {\n      return\n    }\n\n    setBoard((previousBoard) => {\n      const clonedBoard = board.clone()\n\n      clonedBoard.pieces = clonedBoard.pieces.reduce((results, piece) => {\n        if (piece.samePiecePosition(promotionPawn)) {\n          results.push(\n            new Piece(piece.position.clone(), pieceType, piece.team, true)\n          )\n        } else {\n          results.push(piece)\n        }\n\n        return results\n      }, [] as Piece[])\n\n      clonedBoard.calculateAllMoves()\n\n      return clonedBoard\n    })\n\n    // Toggling the modal\n    modalRef.current?.classList.add('hidden')\n  }\n\n  // Deciding the type of color of the pieces when opening the modal\n  function promotionTeamType() {\n    if (promotionPawn?.team === TeamType.RED) {\n      return 'r'\n    } else if (promotionPawn?.team === TeamType.BLUE) {\n      return 'b'\n    } else if (promotionPawn?.team === TeamType.YELLOW) {\n      return 'y'\n    } else if (promotionPawn?.team === TeamType.GREEN) {\n      return 'g'\n    }\n  }\n\n  // Writing the full name of the winning team\n  let teamNames = {\n    [TeamType.RED]: 'Red',\n    [TeamType.BLUE]: 'Blue',\n    [TeamType.YELLOW]: 'Yellow',\n    [TeamType.GREEN]: 'Green',\n  }\n  let teamWon = teamNames[board.currentTeam]\n  let leaderboard = [board.currentTeam, ...board.loseOrder.slice().reverse()]\n\n  let lbPieces = ['Q', 'R', 'N', 'P'] as const\n  let pieceNames = {\n    Q: 'Queen',\n    R: 'Rook',\n    N: 'Knight',\n    P: 'Pawn',\n  }\n\n  function restartGame() {\n    checkmateModalRef.current?.classList.add('hidden')\n\n    setBoard(initialBoard.clone())\n  }\n  \n  return (\n    <>\n      <div className='modal hidden' ref={modalRef}>\n        <div className='modal-body'>\n          <img\n            onClick={() => promotePawn(PieceType.ROOK)}\n            src={`${basePath}/assets/images/${promotionTeamType()}R.png`}\n            alt='Rook'\n          />\n          <img\n            onClick={() => promotePawn(PieceType.KNIGHT)}\n            src={`${basePath}/assets/images/${promotionTeamType()}N.png`}\n            alt='Knight'\n          />\n          <img\n            onClick={() => promotePawn(PieceType.BISHOP)}\n            src={`${basePath}/assets/images/${promotionTeamType()}B.png`}\n            alt='Bishop'\n          />\n          <img\n            onClick={() => promotePawn(PieceType.QUEEN)}\n            src={`${basePath}/assets/images/${promotionTeamType()}Q.png`}\n            alt='Queen'\n          />\n        </div>\n      </div>\n\n      <div className='modal hidden' ref={checkmateModalRef}>\n        <div className='modal-body'>\n          <div className='checkmate-body'>\n            <span>Winner: {teamWon}!</span>\n            <table>\n              <tbody>\n                {leaderboard.map((team, i) => (\n                  <tr key={team} className='team'>\n                    <td>{i + 1}.</td>\n                    <td>{teamNames[team]}</td>\n                    <td>\n                      <img\n                        src={`${basePath}/assets/images/${team}${lbPieces[i]}.png`}\n                        alt={`${teamNames[team]} ${pieceNames[lbPieces[i]]}`}\n                      />\n                    </td>\n                  </tr>\n                ))}\n              </tbody>\n            </table>\n            <button onClick={restartGame}>Play Again</button>\n          </div>\n        </div>\n      </div>\n\n      <Chessboard\n        playMove={playMove}\n        pieces={board.pieces}\n        whoseTurn={board.currentTeam}\n        loseOrder={board.loseOrder}\n        isChecked={board.isChecked}\n      />\n    </>\n  )\n}\n","import './App.css'\nimport Arbiter from './components/Arbiter/Arbiter'\nimport React from 'react'\n// The app component\nfunction App() {\n  return (\n    <div id='app'>\n      <Arbiter />\n    </div>\n  )\n}\n\nexport default App\n","import './index.css'\nimport App from './App'\nimport React from 'react'\nimport ReactDOM from 'react-dom/client'\n\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement)\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n)\n"],"sourceRoot":""}